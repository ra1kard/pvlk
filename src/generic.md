```java
 
```

```java
 
```

```java
 
```


# Обобщения (Generic)

Источник: https://developer.alexanderklimov.ru/android/java/generic.php

Обобщения - это параметризованные типы. 

С их помощью можно: 
- объявлять классы, интерфейсы и методы
- где тип данных указан в виде параметра. 

Обобщения добавили в язык безопасность типов.

Рассмотрим пример с обобщением.

```java
 class Gen<T> {
    T ob; // объявление объекта типа T

    // Передать конструктору ссылку на объект типа T
    Gen(T o) {
        ob = o;
    }

    // Вернуть ob
    T getob() {
        return ob;
    }

    // Показать тип T
    void showType() {
        System.out.println("Тип T: " + ob.getClass().getName());
    }
}

// Код для кнопки
// Работаем с обобщённым классом
// Создаём Gen-ссылку для Integer
Gen<Integer> iOb;

// Создаём объект Gen<Integer>
iOb = new Gen<Integer>(77);

// Показать тип данных, используемый iOb
        iOb.showType();

// Получить значение iOb
int value = iOb.getob();
System.out.println("Значение " + value);

// Создадим объект Gen для String
Gen<String> strOb = new Gen<String>("Обобщённый текст");

// Показать тип данных, используемый strOb
strOb.showType();

// Получить значение strOb
String str = strOb.getob();
System.out.println("Значение: " + str);
```

В результате мы получим:

```java
Типом T является java.lang.Integer
Значение: 77
Типом T является java.lang.String
Значение: Обобщённый текст
```

___

Изучим код. Мы объявили класс в следующей форме:

```java
class Gen<T> {
}
```

В угловых скобках используется T - имя параметра типа. 

Это имя:
- используется в качестве заполнителя, 
- куда будет подставлено имя реального типа, 
- переданного классу Gen при создании реальных типов. 

То есть:
- Параметр типа T применяется в классе всякий раз, 
когда требуется параметр типа. 
- Угловые скобки указывают, что параметр может быть обобщён.
- Сам класс при этом называется обобщённым классом или параметризованным типом.

Далее тип T используется для объявления объекта по имени ob:


```java
T ob; // объявляет объект типа T
```

- Вместо T подставится реальный тип, 
который будет указан при создании объекта класса Gen. 
- Объект ob будет объектом типа, переданного в параметре типа T. 
- Если в параметре T передать тип String, то экземпляр ob будет иметь тип String.

Рассмотрим конструктор Gen().

```java
Get(T o) {
    ob = o;
}
```

Параметр o имеет тип T. 

- Это значит, что реальный тип параметра o определяется типом, 
переданным параметром типа T при создании объекта класса Gen.

___


Параметр типа T также может быть использован для указания типа возвращаемого значения метода:

```java
T getob() {
    return ob;
}
```


## Наименование 

В именах переменных типа принято использовать заглавные буквы. 

Обычно:
- для коллекций используется буква E, 
- буквами K и V - типы ключей и значение (Key/Value), 
- а буквой T (и при необходимости буквы S и U) - любой тип.


___

## Использование

Как использовать обобщённый класс?

Можно создать версию класса Gen для целых чисел:

```java
Gen<Integer> iOb;
```

- в угловых скобках указан тип Integer, 
- т.е. это аргумент типа, который передаётся в параметре типа T класса Gen. 

Фактически:
- мы создаём версию класса Gen, 
- в которой все ссылки на тип T становятся ссылками на тип Integer.

Когда мы присваиваем ссылку на экземпляр, то угловые скобки также требуется указывать.

```java
iOb = new Gen<Integer>(77);
```

Полная версия записи может быть такой:

```java
iOb = new Gen<Integer>(new Integer(88));        // ???????????? оч странно
```

Но такая запись избыточна, 
так как можно использовать автоматическую упаковку значения 77 в нужный формат.

Аналогично, 
можно было бы использовать вариант без автоупаковки для получения значения:

```java
int value = iOb.getob().intValue(); // избыточный код
```

## Обобщения работают только с объектами

Поэтому нельзя использовать в качестве параметра элементарные типы вроде int или char:

```java
Gen<int> intOb = new Gen<int>(44); // нельзя!
```

## Сравнение

- хотя объекты iOb и strOb имеют тип Gen<T>, 
- они являются ссылками на разные типы и их сравнивать нельзя.

```java
iOB = strOb; // нельзя!
```

Использование обобщений:
- автоматически гарантирует безопасность типов во всех операциях, где они задействованы. 
- это очень мощный механизм, широко используемый в Java


# Обобщённый класс с двумя параметрами

Можно указать два и более параметров типа через запятую.

```java
class TwoGen<T, V> {
T ob1;
V ob2;

    // Передать конструктору ссылки на объекты двух типов
    TwoGen(T o1, V o2) {
        ob1 = o1;
        ob2 = o2;
    }
    
    void showTypes() {
        System.out.println("Тип T: " + ob1.getClass().getName());
        System.out.println("Тип V: " + ob2.getClass().getName());
    }
    
    T getob1() {
        return ob1;
    }
    
    V getob2() {
        return ob2;
    }
    
    // Используем созданный класс
    TwoGen<Integer, String> twogenObj = new TwoGen<Integer, String>(77, "Обобщённый текст");
    
    // Узнаем типы
    twogenObj.showTypes();
    
    // Узнаем значения
    int value = twogenObj.getob1();
    System.out.println("Значение: " + value);
    
    String str = twogenObj.getob2();
    System.out.println("Значение: " + str);
}
```

# Обобщённые методы

Никто не запрещает создавать и методы с параметрами и возвращаемыми значениями в виде обобщений.

```java
public static <T> T getSomething(T... a){
    return a;
}
```


# Шаблоны аргументов

Шаблон аргументов указывается символом ? и представляет собой неизвестный тип.

```java
boolean sameAvg(Stats<?> ob) ...
```

По сути, вопрос заменяет Object и мы можем использовать любой класс, который в любом случае будет происходить от Object.

Мы можем ограничить диапазон объектов, указав суперкласс:

```java
public void addItems(ArrayList<? extends Animal> list)
```

- в этом случае можно использовать классы, которые могут быть наследниками Animal - Dog, Cat. 
- а String или Integer вы уже не сможете использовать.

Пример обобщённого метода:

```java
public static <T> T getMiddle(T... a) {
    return a[a.length / 2];
}
```

Переменная типа вводится после модификаторов и перед возвращаемым типом.

___

Отдельно стоит упомянуть новинку JDK 7, позволяющую сократить код:

```java
MyClass<Integer, String> mcObj = new MyClass<Integer, String>(33, "Meow"); // старый способ в JDK 6
MyClass<Integer, String> mcObj = new MyClass<>(33, "Meow"); // новый способ в JDK 7
```
Во второй строке используются только угловые скобки, без указания типов.

Помните, что нельзя создать экземпляр типа параметра.

```java
class Gen {
T ob;

    Gen() {
        ob = new T(); // Недопустимо
    }
}
```



___
___
___

```java
 
```

# Generics

Источник https://blog.skillfactory.ru/glossary/generics/

Дженерики (generics) в языке программирования Java — это сущности, которые могут хранить в себе данные только определенного типа. 

Например, список элементов, в котором могут быть одни числа. 

Но не только: дженерик — обобщенный термин для разных структур.

___

Можно представить дженерик как папку для бумаг:
- куда нельзя положить ничего, кроме документов определенного формата
- это удобно: помогает разделить разные данные и не допустить ситуаций, когда в сущность передается что-то не то

___

Дженерик-сущности еще иногда называют:
- параметризованными
- общими 
- или обобщенными.

Такая сущность создается со специальным параметром. 
 
Параметр позволяет указать, с каким типом данных она будет работать. 
Отсюда и название.

___

В разных источниках можно услышать про:
- «тип-дженерик»
- «класс-дженерик» 
- или «метод-дженерик». 

Это нормально, ведь обобщение и параметризация касаются всех этих сущностей, а generics — общий термин.



## Для чего нужны дженерики

С дженериками работают программисты на Java. 

Без этой возможности писать код, который работает только с определенным видом данных, было сложнее. 

Существовало два способа, и оба неоптимальные:

### Способ 1

Указывать проверку типа в коде:
- например, получать данные — и сразу проверять, 
- а если они не те, выдавать ошибку


- это помогло бы отсеять ненужные элементы
- но если бы класс понадобилось сделать более гибким (например, создать его вариацию для другого типа) его пришлось бы переписывать или копировать. 

 
- не получилось бы просто передать другой специальный параметр, чтобы тот же класс смог работать еще с каким-то типом;

### Способ 2

Полагаться на разработчиков. 

- например, оставлять в коде комментарий «Этот класс работает только с числами».
- слишком велик риск, что кто-то не заметит комментарий и передаст в объект класса не те данные. 
- и хорошо, если ошибка будет заметна сразу, а не уже на этапе тестирования.

Поэтому появились дженерики: они решают эту проблему, делают написание кода проще, а защиту от ошибок надежнее.

___


## Как работают дженерики

Чтобы вернее понять принцип работы, нужно представлять, как устроены сущности в Java. 

- Есть классы — это как бы «чертежи» будущих сущностей, описывающие, что они делают. 
- И есть объекты — экземпляры классов, непосредственно существующие и работающие. Класс — как схема машины, объект — как машина.

Когда разработчик создает дженерик-класс, он приписывает к нему параметр в треугольных скобках — метку. К примеру, так:

```java
class myClass<T>;
```

Теперь при создании объекта этого класса нужно будет указать на месте T название типа, с которым будет работать объект. 

Например, 
- myClass<Integer> <название объекта> для целых чисел 
- или myClass<String> <название объекта> для строк. 


- Сам класс остается универсальным, то есть общим.
- А вот каждый его объект специфичен для своего типа.


С помощью дженериков:
- можно создать один класс, 
- а потом на основе него — несколько объектов этого класса для разных типов. 

Не понадобится дублировать код и усложнять программу. 

Поэтому дженерики лучше и удобнее, чем проверка типа прямо в коде — тогда для каждого типа данных понадобился бы свой класс.

___

## Что такое raw types

В Java есть понятие raw types. 

Так называют дженерик-классы, из которых удалили параметр. 

То есть изначально класс описали как дженерик, но при создании объекта этого класса тип ему не передали. 
То есть что-то вроде myClass<> — тип не указан.


Дословно это название переводится как «сырые типы». 

Пользоваться ими сейчас в коммерческой разработке — чаще всего плохая практика. 

Но в мире все еще много старого кода, который написали до появления дженериков. 

Если такой код еще не успели переписать, в нем может быть очень много «сырых типов». Это надо учитывать, чтобы не возникало проблем с совместимостью.

___ 

## Дженерики-классы и дженерики-методы

Выше мы говорили, что дженериками могут быть разные сущности. 

Разберемся подробнее:

1. дженерик-классы (generic classes) — это классы, «схемы» объектов с параметром. При создании объекта ему передается тип, с которым он будет работать;


2. дженерик-методы (generics methods) — это методы, работающие по такому же принципу. Метод — это функция внутри объекта, то, что он может делать. Методу тип передается при вызове, сразу перед аргументами. Так можно создавать более универсальные функции и применять одну и ту же логику к данным разного типа.


Кстати, дженериками могут быть и встроенные классы или методы, 
и те, которые разработчик пишет самостоятельно. 

Например, встроенный ArrayList — список-массив — работает как дженерик.

___

## Что будет, если передать дженерику не тот тип

Если объекту класса-дженерика передать не тот тип, который указали при его объявлении, он выдаст ошибку. 

Например, если в ходе работы экземпляра myClass<Integer> в нем попытаются сохранить дробное число или даже строку, программа не скомпилируется. 

Вместо этого разработчик увидит ошибку: неверный тип.


Эта ошибка отличается от тех, которые возникнут, если не пользоваться дженериками. 

По ней сразу ясно, из-за чего она возникла и как можно ее исправить. 

Кроме того, она появляется сразу. Поэтому код становится легче отлаживать.



А если отправить «не тот» тип объекту без дженерика, действия с ним выполнятся с ошибкой. Но по этой ошибке не всегда очевидно, чем она вызвана. Худший вариант — код успешно запустится, но сработает неправильно: так ошибку будет найти еще сложнее.














































